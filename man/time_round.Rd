% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/round.R
\name{time_round}
\alias{time_round}
\alias{time_round}
\alias{time_floor}
\alias{time_round}
\alias{time_ceiling}
\title{Round, floor and ceiling for date-time objects}
\usage{
time_round(time, unit = "second", week_start = getOption("week_start", 1))

time_floor(time, unit = "seconds", week_start = getOption("week_start", 1))

time_ceiling(time, unit = "seconds", change_on_boundary = inherits(time,
  "Date"), week_start = getOption("week_start", 1))
}
\arguments{
\item{time}{a date-time vector (\code{Date}, \code{POSIXct} or \code{POSIXlt})}

\item{unit}{a character string specifying a time unit or a multiple of a
unit. Valid base units are \code{second}, \code{minute}, \code{hour}, \code{day}, \code{week},
\code{month}, \code{bimonth}, \code{quarter}, \code{season}, \code{halfyear} and \code{year}. Arbitrary
unique English abbreviations are allowed. With one letter abbreviations "m"
stands for month and "M" stands for minute. Multi-unit rounding of weeks is
currently not supported.}

\item{week_start}{when unit is \code{weeks} specify the reference day. Defaults to
1 (Monday).}

\item{change_on_boundary}{If NULL (the default) don't change instants on the
boundary (\code{time_ceiling(ymd_hms('2000-01-01 00:00:00'))} is \code{2000-01-01 00:00:00}), but round up \code{Date} objects to the next boundary
(\code{time_ceiling(ymd("2000-01-01"), "month")} is \code{"2000-02-01"}). When
\code{TRUE}, instants on the boundary are rounded up to the next boundary. When
\code{FALSE}, date-time on the boundary are never rounded up (this was the
default for \pkg{lubridate} prior to \code{v1.6.0}. See section \code{Rounding Up Date Objects} below for more details.}
}
\value{
An object of the same class as the input object. When input is a
\code{Date} object and unit is smaller than \code{day} a \code{POSIXct} object is
returned.
}
\description{
\pkg{timechange} provides rounding to the nearest unit or
multiple of a unit. Units can be specified flexibly as strings; all common
abbreviations are supported - secs, min, mins, 2 minutes, 3 years, 2s, 1d
etc.

\code{time_round()} takes a date-time object and rounds it to the
nearest value of the specified time unit. For rounding date-times which is
exactly halfway between two consecutive units, the convention is to round
up. Note that this is in line with the behavior of R's
\code{\link[base:round.POSIXt]{base::round.POSIXt()}} function but does not follow the convention of the
base \code{\link[base:round]{base::round()}} function which "rounds to the even digit" per IEC
60559.

\code{time_floor} takes a date-time object and rounds it down to the
nearest boundary of the specified time unit.

\code{time_ceiling()} takes a date-time object and rounds it up to the
nearest boundary of the specified time unit.
}
\section{Civil Time vs Absolute Time rounding}{


Rounding of seconds is done in absolute time (numeric \code{POSIXct}
representation), but all other units are rounded in civil time. There are two
important consequences of this decision. First, rounding of seconds allows
for multi-units larger than 60, while for all other units the maximal
multi-unit is restricted to the containing unit (60 mins, 24 hours
etc). Second, floor (ceiling) in civil time will never produce units larger
(smaller) than the units in the rounded objects. See examples of rounding
around DST transition with \code{1 hour} does not give same result as rounding
with \code{3600 seconds}.

Rounding to fractional seconds is allowed. Please note that rounding to
fractions smaller than 1ms will lead to large precision errors due to the
floating point representation of the POSIXct objects.
}

\section{Ceiling of \code{Date} objects}{


By default rounding up \code{Date} objects follows 3 steps:
\enumerate{
\item Convert to an instant representing lower bound of the Date:
\code{2000-01-01} --> \code{2000-01-01 00:00:00}
\item Round up to the \strong{next} closest rounding unit boundary. For example,
if the rounding unit is \code{month} then next closest boundary of \code{2000-01-01}
is \code{2000-02-01 00:00:00}.

The motivation for this is that the "partial" \code{2000-01-01} is conceptually
an interval (\code{2000-01-01 00:00:00} -- \code{2000-01-02 00:00:00}) and the day
hasn't started clocking yet at the exact boundary \code{00:00:00}. Thus, it
seems wrong to round up a day to its lower boundary.

The behavior on the boundary can be changed by setting
\code{change_on_boundary} to a non-\code{NULL} value.
\item If rounding unit is smaller than a day, return the instant from step 2
(\code{POSIXct}), otherwise convert to and return a \code{Date} object.
}
}

\examples{

## print fractional seconds
options(digits.secs=6)

x <- as.POSIXct("2009-08-03 12:01:59.23")
time_round(x, ".5s")
time_round(x, "sec")
time_round(x, "second")
time_round(x, "minute")
time_round(x, "5 mins")
time_round(x, "5M") # "M" for minute "m" for month
time_round(x, "hour")
time_round(x, "2 hours")
time_round(x, "2h")
time_round(x, "day")
time_round(x, "week")
time_round(x, "month")
time_round(x, "bimonth")
time_round(x, "quarter") == time_round(x, "3 months")
time_round(x, "halfyear")
time_round(x, "year")

x <- as.POSIXct("2009-08-03 12:01:59.23")
time_floor(x, ".1s")
time_floor(x, "second")
time_floor(x, "minute")
time_floor(x, "M")
time_floor(x, "hour")
time_floor(x, "day")
time_floor(x, "week")
time_floor(x, "m")
time_floor(x, "month")
time_floor(x, "bimonth")
time_floor(x, "quarter")
time_floor(x, "season")
time_floor(x, "halfyear")
time_floor(x, "year")

x <- as.POSIXct("2009-08-03 12:01:59.23")
time_ceiling(x, ".1 sec")
time_ceiling(x, "second")
time_ceiling(x, "minute")
time_ceiling(x, "5 mins")
time_ceiling(x, "hour")
time_ceiling(x, "day")
time_ceiling(x, "week")
time_ceiling(x, "month")
time_ceiling(x, "bimonth") == time_ceiling(x, "2 months")
time_ceiling(x, "quarter")
time_ceiling(x, "season")
time_ceiling(x, "halfyear")
time_ceiling(x, "year")

## behavior on the boundary
x <- as.Date("2000-01-01")
time_ceiling(x, "month")
time_ceiling(x, "month", change_on_boundary = FALSE)

## As of R 3.4.2 POSIXct printing of fractional numbers is wrong
as.POSIXct("2009-08-03 12:01:59.3") ## -> "2009-08-03 12:01:59.2 CEST"
time_ceiling(x, ".1 sec") ## -> "2009-08-03 12:01:59.2 CEST"

## Civil Time vs Absolute Time Rounding

# "2014-11-02 01:35:00 EDT" before 1h backroll at 2AM
x <- .POSIXct(1414906500, tz = "America/New_York")
x
time_ceiling(x, "hour") # "2014-11-02 02:00:00 EST" + 1h 25m
difftime(time_ceiling(x, "hour"), x, units = "min")
time_ceiling(x, "3600s") # "2014-11-02 01:00:00 EST" + 25m
difftime(time_ceiling(x, "3600s"), x, units = "min")

# "2014-11-02 01:25:00 EST" after 1h backroll at 2AM
x <- .POSIXct(1414909500, tz = "America/New_York")
x
time_floor(x, "hour") # "2014-11-02 01:00:00 EST"  - 25m
difftime(time_floor(x, "hour"), x, units = "min")
time_floor(x, "3600s") # "2014-11-02 01:00:00 EST"  - 25m
difftime(time_floor(x, "3600s"), x, units = "min")
}
\seealso{
\code{\link[base:round]{base::round()}}
}
