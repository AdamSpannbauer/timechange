% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/addition.R
\name{time_add}
\alias{time_add}
\alias{time_subtract}
\title{Arithmetics with periods}
\usage{
time_add(time, periods = NULL, years = NULL, months = NULL,
  weeks = NULL, days = NULL, hours = NULL, minutes = NULL,
  seconds = NULL, adjust_month = c("firstday", "lastday", "boundary",
  "none", "NA"), roll_dst = TRUE)

time_subtract(time, periods = NULL, years = NULL, months = NULL,
  weeks = NULL, days = NULL, hours = NULL, minutes = NULL,
  seconds = NULL, adjust_month = c("firstday", "lastday", "boundary",
  "none", "NA"), roll_dst = TRUE)
}
\arguments{
\item{time}{date-time object}

\item{periods}{string or list (currently unimplemented)}

\item{years}{years,months,weeks,days,hours,minutes,seconds Units to be added
to \code{time}. Each unit except for seconds must be expressed as integer
values.}

\item{adjust_month}{controls how addition of months and years behaves when
standard arithmetic rules exceed limits of the resulting date's month. See
Details for the description of possible values.}

\item{roll_dst}{if \code{TRUE} and the resulting date-time falls within the DST
gap, the time is rolled forward to the closest valid civil time. If FALSE,
NA is returned.}
}
\description{
Add periods to date-time objects. Periods track the change in
the "clock time" between two civil times. They are measured in common
civil time units: years, months, days, hours, minutes, and seconds.

Arithmetic operations with multiple period units (years, months
etc) are applied in decreasing size order, from year to second. Thus
\code{time_add(x, months = 1, days = 3)} first adds 1 to \code{x} and then 3
days.

Generally period arithmetic is undefined due to the irregular nature of
civil time and complexities with DST transitions. \pkg{`timechange`} allows
for a refined control of what happens when an addition of irregular periods
(years, months, days) results in "unclear" date.

Let's start with an example. What happens when you add "1 month 3 days" to
"2000-01-31 01:02:03"? \pkg{`timechange`} operates by applying larger
periods first. First months are added\code{1 + 1 = February} which results in
non-existent time of \code{2000-02-31 01:02:03}. Here the \code{adjust_month}
adjustment kicks in:
\itemize{
\item \code{none} - no adjustment is done to the simple arithmetic operations. Days
are simply rolled over the calendar. Thus, \code{2000-01-31 01:02:03 + 1 month + 3 days}
is equivalent to \code{2000-02-01 01:02:03 + 34 days} resulting in \code{2000-03-05 01:02:03}.
\item \code{NA} - if any of the intermediate additions result in non-existent dates
\code{NA} is produced. This is the how arithmetic in \code{lubridate} operates.
\item \code{boundary} - if an intermediate computation results in a non-existent
date, the date is adjusted to the boundary between the months. Thus,
\code{2000-01-31 01:02:03 + month = 2000-03-01 00:00:00}. Adding 3 days results
in \code{2000-03-03 00:00:00}.
\item \code{firstday} - is like \code{boundary} but preserves the sub-day units. Thus,
\code{2000-01-31 01:02:03 + 1 month = 2000-03-01 01:02:03}.
\item \code{lastday} - is like \code{firstday} but instead of rolling forward to the first
day of the month, it rolls back to the last valid day of the previous
month. Thus, \code{2000-01-31 01:02:03 + month = 2000-02-28 01:02:03}.
}

For the purpose of the month adjustment simultaneous addition of \code{y} years
and \code{m} months is equivalent to adding \code{12*y + m} months. Thus \code{2000-02-29 + year + month} is equivalent to \code{2000-02-29 + 13 months} and results in a
valid date \code{2001-03-29}.
}
\examples{

x <- as.POSIXct("2000-01-31 01:02:03", tz = "America/Chicago")
time_add(x, months = 1, adjust_month = "firstday")
time_add(x, months = 1, adjust_month = "lastday")
time_add(x, months = 1, adjust_month = "boundary")
time_add(x, months = 1, adjust_month = "none")
time_add(x, months = 1, adjust_month = "NA")

time_add(x, months = 1, days = 3,  adjust_month = "firstday")
time_add(x, months = 1, days = 3,  adjust_month = "lastday")
time_add(x, months = 1, days = 3,  adjust_month = "boundary")
time_add(x, months = 1, days = 3,  adjust_month = "none")
time_add(x, months = 1, days = 3,  adjust_month = "NA")

x <- as.POSIXct("2000-03-1 01:02:03", tz = "America/Chicago")
time_subtract(x, months = 1, adjust_month = "firstday")
time_subtract(x, months = 1, adjust_month = "lastday")
time_subtract(x, months = 1, adjust_month = "boundary")
time_subtract(x, months = 1, adjust_month = "none")
time_subtract(x, months = 1, adjust_month = "NA")

time_add(x, months = 1, days = 3,  adjust_month = "firstday")
time_add(x, months = 1, days = 3,  adjust_month = "lastday")
time_add(x, months = 1, days = 3,  adjust_month = "boundary")
time_add(x, months = 1, days = 3,  adjust_month = "none")
time_add(x, months = 1, days = 3,  adjust_month = "NA")
}
